<script>
    async function fetchGraphData() {
        const graphData = await fetch('/graph.json').then(res => res.json());
        const fullGraphData  = filterFullGraphData(graphData);
        return {graphData, fullGraphData}
    }

    function getNextLevelNeighbours(existing, remaining) {
        const keys = Object.values(existing).map((n) => n.neighbors).flat();
        const n_remaining = Object.keys(remaining).reduce((acc, key) => {
                if (keys.indexOf(key) != -1) {
                    if (!remaining[key].hide) {
                        existing[key] = remaining[key];
                    }
                } else {
                    acc[key] = remaining[key];
                }
                return acc;
            }, {});
        return existing, n_remaining;
    }

     function filterLocalGraphData(graphData, depth) {
        if (graphData == null) {
            return null;
        }
        let remaining = JSON.parse(JSON.stringify(graphData.nodes));
        let links = JSON.parse(JSON.stringify(graphData.links));
        let currentLink = decodeURI(window.location.pathname);
        let currentNode = remaining[currentLink] || Object.values(remaining).find((v) => v.home);
        delete remaining[currentNode.url];
        if (!currentNode.home) {
            let home = Object.values(remaining).find((v) => v.home);
            delete remaining[home.url];
        }
        currentNode.current = true;
        let existing = {};
        existing[currentNode.url] = currentNode;
        for (let i = 0; i < depth; i++) {
            existing, remaining = getNextLevelNeighbours(existing, remaining);
        }
        nodes = Object.values(existing);
        if (!currentNode.home) {
            nodes = nodes.filter(n => !n.home);
        }
        let ids = nodes.map((n) => n.id);
        return {
            nodes,
            links: links.filter(function (con) {
                return ids.indexOf(con.target) > -1 && ids.indexOf(con.source) > -1;
            }),
        }
    }


    function getCssVar(variable) {return getComputedStyle(document.body).getPropertyValue(variable)}

    function htmlDecode(input) {
        var doc = new DOMParser().parseFromString(input, "text/html");
        return doc.documentElement.textContent;
    }

    function renderGraph(graphData, id, delay, fullScreen) {
        if (graphData == null) {
            return;
        }
        const el = document.getElementById(id); 


        window.addEventListener('resize', () => {
            if (Graph) {
                Graph.width(el.offsetWidth);
                Graph.height(el.offsetHeight);
            }
        });        


        width = el.offsetWidth;
        height = el.offsetHeight;
        const highlightNodes = new Set();
        let hoverNode = null;
        const selectedNodes = new Set();
        const nodeMap = Object.fromEntries(graphData.nodes.map(node => [node.url, node]));

        const color = getCssVar("--graph-main");
        const mutedColor = getCssVar("--graph-muted");
        const layoutKey = 'graph-layout-' + id;
        let savedLayout = {};
        try {
            savedLayout = JSON.parse(localStorage.getItem(layoutKey) || '{}');
        } catch {}

        const linkCurvature = 0.4; 
        const linksByPair = {};
        graphData.links.forEach(link => {
            const source = typeof link.source === 'object' ? link.source.id : link.source;
            const target = typeof link.target === 'object' ? link.target.id : link.target;
            const pairKey = [source, target].sort().join('-');
            if (!linksByPair[pairKey]) {
                linksByPair[pairKey] = [];
            }
            linksByPair[pairKey].push(link);
        });
        Object.values(linksByPair).forEach(linksInPair => {
            if (linksInPair.length > 1) {
                // If we have multiple links between two nodes (e.g. A->B and B->A)
                // We want them to separate.
                
                // Check if they are in the same direction or opposite
                const link1 = linksInPair[0];
                const link2 = linksInPair[1];
                
                const l1Source = typeof link1.source === 'object' ? link1.source.id : link1.source;
                const l2Source = typeof link2.source === 'object' ? link2.source.id : link2.source;
                
                if (l1Source === l2Source) {
                     // Same direction (A->B and A->B): Use opposite curvatures to separate
                    link1.curvature = linkCurvature;
                    link2.curvature = -linkCurvature;
                } else {
                    // Opposite direction (A->B and B->A): Use SAME curvature 
                    // Because "Right" for A->B is physically opposite to "Right" for B->A
                    link1.curvature = linkCurvature;
                    link2.curvature = linkCurvature;
                }
            } else {
                linksInPair.forEach(l => l.curvature = 0);
            }
        });

        if (id === 'full-graph-container' && savedLayout && graphData && graphData.nodes) {
            graphData.nodes.forEach(node => {
                if (savedLayout[node.id]) {
                    node.x = savedLayout[node.id].x;
                    node.y = savedLayout[node.id].y;
                    node.fx = savedLayout[node.id].fx;
                    node.fy = savedLayout[node.id].fy;
                }
            });
        }
        function getNodeColorByPath(dgPath, defaultColor) {
            if (!dgPath) return defaultColor;
            if (dgPath.includes("代数")) return "#F59E0B";    
            if (dgPath.includes("机器人")) return "#84CC16";
            if (dgPath.includes("过程控制")) return "#9A4E90";
            if (dgPath.includes("智能")) return "#FF0000";
            if (dgPath.includes("控制")) return "#7496ff";
            if (dgPath.includes("数学")) return "#c44f70";
            return defaultColor;
        }
        let Graph = ForceGraph()
        (el)
            .graphData(graphData)
            .nodeId('id')
            .nodeLabel('title')
            .linkSource('source')
            .linkTarget('target')
            .linkCurvature('curvature') // --- NEW --- Apply curvature
            .d3AlphaDecay(0.10)
            .width(width)
            .height(height)
            .linkDirectionalArrowLength(2)
            .linkDirectionalArrowRelPos(0.5)
            .autoPauseRedraw(false)
            .linkColor((link) => {
                const defaultLinkColor = id === 'full-graph-container' ? mutedColor : color;
                const sourceUrl = link.source.url;
                const targetUrl = link.target.url;

                const primaryHighlightUrls = new Set();
                if (hoverNode) primaryHighlightUrls.add(hoverNode.url);
                selectedNodes.forEach(url => primaryHighlightUrls.add(url));

                if (primaryHighlightUrls.size === 0) {
                    return defaultLinkColor;
                }
                
                if (primaryHighlightUrls.has(sourceUrl) || primaryHighlightUrls.has(targetUrl)) {
                    return color;
                } else {
                    return mutedColor;
                }
            })
            .nodeCanvasObject((node, ctx) => {
                const numberOfNeighbours = (node.neighbors && node.neighbors.length) || 2;
                const nodeR = Math.min(7, Math.max(numberOfNeighbours / 2, 2));
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeR, 0, 2 * Math.PI, false);
                let nodeColor = getNodeColorByPath(node.url, color);

                let isHighlighted = false;
                const isHovered = highlightNodes.has(node.url);

                if (selectedNodes.size > 0) {
                    const selectionHighlights = new Set();
                    selectedNodes.forEach(selectedUrl => {
                        selectionHighlights.add(selectedUrl);
                        const selectedNodeObj = nodeMap[selectedUrl];
                        if (selectedNodeObj && selectedNodeObj.neighbors) {
                            selectedNodeObj.neighbors.forEach(neighborUrl => selectionHighlights.add(neighborUrl));
                        }
                    });
                    isHighlighted = selectionHighlights.has(node.url) || isHovered;
                } else {
                    isHighlighted = (hoverNode == null) || isHovered;
                }
                
                ctx.fillStyle = isHighlighted ? nodeColor : mutedColor;
                 
                ctx.fill();
                
                // Marker for selected nodes
                if (selectedNodes.has(node.url)) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeR + 2, 0, 2 * Math.PI, false); 
                    ctx.lineWidth = 1; 
                    ctx.strokeStyle = color; 
                    ctx.stroke();
                }

                if (node.current) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeR + 1, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = color;
                    ctx.stroke();
                }

                const label = htmlDecode(node.title)
                const fontSize = 3.5;
                ctx.font = `${fontSize}px Sans-Serif`;

                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(label, node.x, node.y + nodeR + 2);
            })
            .onNodeClick(node => {
                window.location = node.url;
            })
            .onNodeRightClick(node => {
                if (selectedNodes.has(node.url)) {
                    selectedNodes.delete(node.url);
                } else {
                    selectedNodes.add(node.url);
                }
                return false;
            })
            .onNodeHover(node => {
                highlightNodes.clear();
                if (node) {
                    highlightNodes.add(node.url);
                    node.neighbors.forEach(neighborUrl => highlightNodes.add(neighborUrl));
                }
                hoverNode = node || null;
            })
            .onNodeDragEnd(node => {
                if (id === 'full-graph-container') {
                    const layout = {};
                    graphData.nodes.forEach(n => {
                        layout[n.id] = {
                            x: n.x,
                            y: n.y,
                            fx: n.fx,
                            fy: n.fy
                        };
                    });
                    localStorage.setItem(layoutKey, JSON.stringify(layout));
                }
            });

            // Conditionally set graph physics
            if (id === 'full-graph-container') {
                Graph.d3Force('link').distance(10);
                Graph.d3Force('charge').strength(-60);
            }
            
            if (fullScreen || (delay != null && graphData.nodes.length > 4)) {
                setTimeout(() => {
                    Graph.zoomToFit(5, 75);
                }, delay || 200);
            }
        return Graph;
    }

    function renderLocalGraph(graphData, depth, fullScreen) {
        if (window.graph){
            window.graph._destructor();
        }
        const data = filterLocalGraphData(graphData, depth);
        return renderGraph(data, 'link-graph', null, fullScreen);
    }

    function filterFullGraphData(graphData) {
        if (graphData == null) {
            return null;
        }
        graphData = JSON.parse(JSON.stringify(graphData));
        const hiddens = Object.values(graphData.nodes).filter((n) => n.hide).map((n) => n.id);
        const data = {
            links: JSON.parse(JSON.stringify(graphData.links)).filter((l) => hiddens.indexOf(l.source) == -1 && hiddens.indexOf(l.target) == -1),
            nodes: [...Object.values(graphData.nodes).filter((n) => !n.hide)]
        }
        return data
    }

    function openFullGraph(fullGraphData) {
        lucide.createIcons({
                attrs: {
                    class: ["svg-icon"]
                }
            });
        return renderGraph(fullGraphData, "full-graph-container", 200, false);;
    }

    function closefullGraph(fullGraph) {
        if (fullGraph) {
            fullGraph._destructor();
        }
        return null;
    }
</script>
<div @toggle-graph-fullscreen.window="fullScreen = !fullScreen" x-init="{graphData, fullGraphData} = await fetchGraphData();" x-data="{ graphData: null, depth: 1, graph: null, fullGraph: null, showFullGraph: false, fullScreen: false, fullGraphData: null}" id="graph-component" x-bind:class="fullScreen ? 'graph graph-fs' : 'graph'" x-effect="const sidebar = $el.closest('.sidebar'); if (sidebar) { fullScreen ? sidebar.classList.add('on-top') : sidebar.classList.remove('on-top') }; fullScreen ? document.body.classList.add('has-fullscreen-graph') : document.body.classList.remove('has-fullscreen-graph');" v-scope>
    <div class="graph-title-container">
        <div class="graph-title">关系图谱 Graph</div>
        <div id="graph-controls">
                <div class="depth-control">
                    <label for="graph-depth">Depth</label>
                    <div class="slider">
                            <input x-model.number="depth" name="graph-depth" list="depthmarkers" type="range" step="1" min="1" max="3" id="graph-depth"/>
                    <datalist id="depthmarkers">
                            <option value="1" label="1"></option>
                            <option value="2" label="2"></option>
                            <option value="3" label="3"></option>
                    </datalist>
                    </div>
                    <span id="depth-display" x-text="depth"></span>
                </div>
                <div class="ctrl-right">
                    <span id="global-graph-btn" x-on:click="showFullGraph = true; fullScreen = true; setTimeout(() => {fullGraph = openFullGraph(fullGraphData)}, 100)"><i  icon-name="globe" aria-hidden="true"></i></span>
                    <span  id="graph-fs-btn"  x-on:click="fullScreen = !fullScreen"><i  icon-name="expand" aria-hidden="true"></i></span>
                </div>
        </div>
    </div>
    <div x-effect="if (graphData) window.graph = renderLocalGraph(graphData, depth, fullScreen)" id="link-graph" ></div>
    <div x-show="showFullGraph" id="full-graph" class="show" style="display: none;">
        <span id="full-graph-close" x-on:click="fullGraph = closefullGraph(fullGraph); showFullGraph = false; fullScreen = false;"><i icon-name="x" aria-hidden="true"></i></span><div id="full-graph-container"></div>
    </div>
</div>
